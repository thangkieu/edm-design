{"version":3,"sources":["components/Editor/TinyEditor.tsx"],"names":["Wrapper","styled","div","TinyEditor","memo","onChange","placeholder","value","tinymceRef","useRef","wrapperElRef","handleChange","useCallback","current","getContent","useEffect","initTinyMce","off","destroy","el","a","renderTinyMce","ins","length","setContent","on","hasFocus","ref"],"mappings":"6LAaMA,EAAUC,IAAOC,IAAV,2KAaPC,EAAaC,gBAAsB,YAAuC,IAApCC,EAAmC,EAAnCA,SAAUC,EAAyB,EAAzBA,YAAaC,EAAY,EAAZA,MAC3DC,EAAaC,mBACbC,EAAeD,mBAEfE,EAAeC,uBAAY,WAAO,IAAD,EAC7B,OAARP,QAAQ,IAARA,KAAQ,UAAGG,EAAWK,eAAd,aAAG,EAAoBC,gBAC9B,CAACT,IAoCJ,OAlCAU,qBAAU,WACR,GAAKL,EAAaG,QAmBlB,OAJKL,EAAWK,SAhBF,oCAiBZG,CAAYN,EAAaG,SAGpB,WAAO,IAAD,MACX,UAAAL,EAAWK,eAAX,SAAoBI,IAAI,QAASN,GACjC,UAAAH,EAAWK,eAAX,SAAoBI,IAAI,SAAUN,GAClC,UAAAH,EAAWK,eAAX,SAAoBK,UACpBV,EAAWK,QAAU,MAxBT,4CAGd,WAA2BM,GAA3B,eAAAC,EAAA,yDACOD,EADP,iEAGoBE,YAAcF,EAAIb,GAHtC,QAKS,QAFDgB,EAHR,cAKS,IAAHA,OAAA,EAAAA,EAAKC,QAAS,IAChBf,EAAWK,QAAUS,EAAI,GACzBd,EAAWK,QAAQW,WAAWjB,GAAS,IACvCC,EAAWK,QAAQY,GAAG,QAASd,GAC/BH,EAAWK,QAAQY,GAAG,SAAUd,IATpC,4CAHc,yBA2Bb,IAEHI,qBAAU,WAAO,IAAD,MACVR,KAAK,UAAKC,EAAWK,eAAhB,aAAK,EAAoBC,gBAAgB,UAACN,EAAWK,eAAZ,aAAC,EAAoBa,aACrE,UAAAlB,EAAWK,eAAX,SAAoBW,WAAWjB,GAAS,MACzC,CAACA,IAEG,cAACP,EAAD,CAAS2B,IAAKjB,OAGRP","file":"static/js/7.426caef6.chunk.js","sourcesContent":["import { renderTinyMce } from '@utils/tinymce';\nimport { memo, useCallback, useEffect, useRef } from 'react';\nimport styled from 'styled-components';\nimport { Editor as TinyMceEditor } from 'tinymce';\n\nexport interface TinyEditorProps {\n  ref?: any;\n  onChange?: React.EventHandler<any>;\n  placeholder?: string;\n  value?: string;\n  id?: string;\n}\n\nconst Wrapper = styled.div`\n  min-height: 10rem;\n  outline: 1px solid #dddddd;\n\n  [aria-placeholder] {\n    overflow: hidden;\n  }\n\n  * {\n    max-width: 100%;\n  }\n`;\n\nconst TinyEditor = memo<TinyEditorProps>(({ onChange, placeholder, value }) => {\n  const tinymceRef = useRef<TinyMceEditor | null>();\n  const wrapperElRef = useRef<HTMLDivElement>();\n\n  const handleChange = useCallback(() => {\n    onChange?.(tinymceRef.current?.getContent());\n  }, [onChange]);\n\n  useEffect(() => {\n    if (!wrapperElRef.current) return;\n\n    async function initTinyMce(el: HTMLElement) {\n      if (!el) return;\n\n      const ins = await renderTinyMce(el, placeholder);\n\n      if (ins?.length > 0) {\n        tinymceRef.current = ins[0];\n        tinymceRef.current.setContent(value || '');\n        tinymceRef.current.on('input', handleChange);\n        tinymceRef.current.on('change', handleChange);\n      }\n    }\n\n    if (!tinymceRef.current) {\n      initTinyMce(wrapperElRef.current);\n    }\n\n    return () => {\n      tinymceRef.current?.off('input', handleChange);\n      tinymceRef.current?.off('change', handleChange);\n      tinymceRef.current?.destroy();\n      tinymceRef.current = null;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (value !== tinymceRef.current?.getContent() && !tinymceRef.current?.hasFocus())\n      tinymceRef.current?.setContent(value || '');\n  }, [value]);\n\n  return <Wrapper ref={wrapperElRef as any} />;\n});\n\nexport default TinyEditor;\n"],"sourceRoot":""}